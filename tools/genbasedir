#!/bin/sh
#
# $Id: genbasedir,v 1.6 2002/09/04 22:48:37 niemeyer Exp $
#
# Этот скрипт генерирует содержимое каталога base/, создавая:
# - pkglists/srclists
# - Release (и при необходимости legacy hashfile)
# Обновляйте набор компонентов так, чтобы он соответствовал структуре вашего репозитория.
#

usage="\
Использование: genbasedir [<параметры>] <topdir> [<comp1> [<comp2> ...]]\n\
\n\
Параметры:\n\
   -s, --sign         Сгенерировать и подписать Release/хэши\n\
   --default-key=ID   Использовать ID как секретный ключ gnupg\n\
   --hashonly         Делать только хэши (без генерации списков)\n\
   --listonly         Сгенерировать pkglists/srclists и выйти\n\
   --partial          Обновить только часть уже существующих компонентов\n\
   --oldhashfile      Включить генерацию старого hashfile\n\
   --bz2only          Генерировать только сжатые списки\n\
   --progress         Показывать прогресс-бары для genpkglist/gensrclist\n\
   --updateinfo=FILE  Файл информации об обновлениях\n\
   --flat             Плоский репозиторий: SRPMS и RPMS лежат в topdir\n\
                      (SRPMS обычно лежат в 'topdir/..')\n\
   --bloat            Не урезать список файлов пакета (нужно для некоторых\n\
                      дистрибутивов с неавтоматически вычисляемыми зависимостями\n\
                      по файлам)\n\
   --meta=NAME        Создать meta-репозиторий с именем NAME\n\
   --compresslevel=n  Уровень сжатия bzip2 (1-9)\n\
   --cachedir=DIR     Свой каталог кэша md5sum для генерации списков\n\
                      (удобно для пользователей без root).\n\
   --topdir=DIR       (Устар.) Задать topdir через опцию (вместо позиционного)\n\
   --append           (Истор.) Передать --append генераторам списков\n\
   --mapi             (Служебное) Режим mapi для gensrclist\n\
   -h, --help         Показать эту справку\n\
\n\
Примеры:\n\
\n\
   genbasedir /home/ftp/pub/conectiva\n\
   genbasedir /home/ftp/pub/conectiva main extra devel\n\
"

print_usage() {
	# %b — чтобы \n в строке usage корректно интерпретировались
	printf "%b" "$usage"
}

die() {
	# Сообщение об ошибке в stderr
	printf "%s\n" "$*" 1>&2
	exit 1
}

getsize() {
	# Возвращает размер файла в байтах (устойчиво к пробелам в имени)
	# wc может печатать пробелы — awk забирает только число
	wc -c < "$1" 2>/dev/null | awk '{print $1}'
}

phashstuff() {
	# Печатает строку вида: " <md5> <size> <path>"
	size=$(getsize "$1")
	md5=$(md5sum "$1" 2>/dev/null | awk '{print $1}')
	printf " %s %s %s\n" "$md5" "$size" "$2"
}

basedir=.
signature=0
listonly=0
hashonly=0
partial=0
oldhashfile=0
mapi=0
bz2only=0
meta=
meta_opts=
updateinfo=
progress=
flat=
defaultkey=
srcidxdir=
append=0
append_opt=
bz2opts=
cachedir=
cacheopts=
legacy_topdir=

# bloat нужен для не-Conectiva дистрибутивов (как минимум RH),
# т.к. там используются файловые зависимости с непредсказуемой
# эвристикой — нельзя безопасно выкинуть пути, которые могут
# внезапно появиться в Requires.
bloat=""

while test $# -gt 0 ; do
	case "$1" in
	-h | --help)
		print_usage
		exit 0
	;;
	--mapi)
		# хи-хи-хи..
		mapi=1
	;;
	--listonly)
		listonly=1
	;;
	--hashonly)
		hashonly=1
	;;
	--partial)
		partial=1
	;;
	--oldhashfile)
		oldhashfile=1
	;;
	--bz2only)
		bz2only=1
	;;
	--append)
		append=1
	;;
	--meta=*)
		meta=${1#--meta=}
		meta_opts="--append --meta $meta"
	;;
	--updateinfo=*)
		updateinfo=${1#--updateinfo=}
	;;
	--bloat)
		bloat="--bloat"
	;;
	--topdir=*)
		# Устаревший способ задания topdir (без позиционного аргумента)
		legacy_topdir=${1#--topdir=}
	;;
	--progress)
		progress="--progress"
	;;
	--flat)
		flat="--flat"
	;;
	-s | --sign)
		signature=1
	;;
	--default-key=*)
		# Сохраняем как единый аргумент, даже если пользователь дал значение с пробелами (в кавычках)
		defaultkey="\"$1\""
	;;
	--compresslevel=*)
		bz2opts="-${1#--compresslevel=}"
	;;
	--cachedir=*)
		cachedir=${1#--cachedir=}
		cacheopts="--cachedir $cachedir"
		[ -d "$cachedir/genpkglist" ] || mkdir -p "$cachedir/genpkglist"
		[ -d "$cachedir/gensrclist" ] || mkdir -p "$cachedir/gensrclist"
	;;
	-*)
		print_usage 1>&2
		exit 1
	;;
	*)
		break
	;;
	esac
	shift
done

# Если topdir не задан опцией, ожидаем его первым позиционным параметром
if [ -n "$legacy_topdir" ]; then
	topdir=$legacy_topdir
else
	[ $# -gt 0 ] || { print_usage 1>&2; exit 1; }
	topdir=$1
	shift
fi

# Сохраняем историческое поведение: принудительно добавляем ведущий '/'
# (//... схлопнется в /... благодаря tr -s /)
topdir=$(printf "%s" "/$topdir" | tr -s /)

components="$*"

basedir_=base
basedir=$(printf "%s" "$topdir/$basedir_" | tr -s /)

pkglist_=$basedir_/pkglist
srclist_=$basedir_/srclist
release_=$basedir_/release
pkglist=$basedir/pkglist
srclist=$basedir/srclist
release=$basedir/release

[ -d "$topdir" ] || die "ошибка: неверный topdir: $topdir"

if [ ! -d "$basedir" ]; then
	printf "%s" "Создаю каталог base... "
	mkdir -p "$basedir" || die "ошибка: не удалось создать каталог: $basedir"
	printf "%s\n" "готово"
fi

# Если компонентов не указали — пытаемся обнаружить их по RPMS.* / SRPMS.*
if [ -z "$components" ]; then
	comps=$basedir/.components.tmp
	rm -f "$comps"
	: > "$comps" || die "ошибка: не удалось создать временный файл: $comps"

	for dir in $topdir/RPMS.* $topdir/SRPMS.* $topdir/../SRPMS.*; do
		if [ -d "$dir" ]; then
			# Эквивалент sed 's/.*\.//' — берём всё после последней точки
			printf "%s\n" "${dir##*.}" >> "$comps"
		fi
	done

	components=$(sort -u "$comps" 2>/dev/null | tr '\n' ' ' | sed 's/[[:space:]]*$//')
	rm -f "$comps"
fi

if [ -z "$components" ]; then
	die "ошибка: компоненты не найдены"
else
	printf "%s\n" "Компоненты: $components"
fi

# Если пользователь явно просил --append (без meta), пробрасываем его дальше
if [ "$append" -eq 1 ] && [ -z "$meta" ]; then
	append_opt="--append"
fi

if [ "$hashonly" -ne 1 ]; then

	# ----------------
	# Списки пакетов
	# ----------------

	: "${TMPDIR:=/tmp}"
	srcidxdir=$(mktemp -d "$TMPDIR/genbasedir.XXXXXX" 2>/dev/null)

	if [ -z "$srcidxdir" ] || [ ! -d "$srcidxdir" ]; then
		srcidxdir=$basedir/.srcidxtmp.$$
		mkdir -p "$srcidxdir" || die "ошибка: не удалось создать временный каталог"
	fi

	printf "%s" "Обрабатываю pkglists..."

	# Если создаём meta-репозиторий — сохраняем старый pkglist вне цикла
	if [ -n "$meta" ]; then
		if [ -f "$basedir/pkglist.$meta" ]; then
			mv -f "$basedir/pkglist.$meta" "$basedir/pkglist.$meta.old"
		fi
	fi

	# Общий индекс (накапливаем)
	: > "$srcidxdir/srcidx" 2>/dev/null || true

	for comp in $components; do
		if [ ! -d "$topdir/RPMS.$comp" ]; then
			continue
		fi

		printf " %s" "$comp"

		# Обычный репозиторий: сохраняем старый pkglist внутри цикла
		if [ -z "$meta" ]; then
			if [ -f "$basedir/pkglist.$comp" ]; then
				mv -f "$basedir/pkglist.$comp" "$basedir/pkglist.$comp.old"
			fi
		fi

		if [ -z "$updateinfo" ]; then
			(
				cd "$basedir" || exit 1
				genpkglist $progress $bloat $meta_opts $append_opt $cacheopts \
					--index "$srcidxdir/srcidx.$comp" "$topdir" "$comp"
			) || die "ошибка: genpkglist завершился с ошибкой (компонент: $comp)"
		else
			(
				cd "$basedir" || exit 1
				genpkglist $progress $bloat $meta_opts $append_opt $cacheopts \
					--index "$srcidxdir/srcidx.$comp" --info "$updateinfo" "$topdir" "$comp"
			) || die "ошибка: genpkglist завершился с ошибкой (компонент: $comp)"
		fi

		if [ -z "$meta" ] && [ -f "$basedir/pkglist.$comp" ]; then

			# Сравнение с предыдущим pkglist
			if [ -f "$basedir/pkglist.$comp.old" ]; then
				if cmp -s "$basedir/pkglist.$comp.old" "$basedir/pkglist.$comp"; then
					mv -f "$basedir/pkglist.$comp.old" "$basedir/pkglist.$comp"
				fi
			fi

			# Сохраняем старый сжатый pkglist
			if [ -f "$basedir/pkglist.$comp.bz2" ]; then
				mv -f "$basedir/pkglist.$comp.bz2" "$basedir/pkglist.$comp.bz2.old"
			fi

			# Сжимаем
			bzip2 $bz2opts -c "$basedir/pkglist.$comp" > "$basedir/pkglist.$comp.bz2"

			# Сравнение с предыдущим сжатым pkglist
			if [ -f "$basedir/pkglist.$comp.bz2.old" ]; then
				if cmp -s "$basedir/pkglist.$comp.bz2.old" "$basedir/pkglist.$comp.bz2"; then
					mv -f "$basedir/pkglist.$comp.bz2.old" "$basedir/pkglist.$comp.bz2"
				fi
			fi

			rm -f "$basedir/pkglist.$comp.old" "$basedir/pkglist.$comp.bz2.old"
		fi

		# Накапливаем индексы
		if [ -f "$srcidxdir/srcidx.$comp" ]; then
			cat "$srcidxdir/srcidx.$comp" >> "$srcidxdir/srcidx"
		fi
	done

	if [ -n "$meta" ] && [ -f "$basedir/pkglist.$meta" ]; then

		# Сравнение с предыдущим pkglist
		if [ -f "$basedir/pkglist.$meta.old" ]; then
			if cmp -s "$basedir/pkglist.$meta.old" "$basedir/pkglist.$meta"; then
				mv -f "$basedir/pkglist.$meta.old" "$basedir/pkglist.$meta"
			fi
		fi

		# Сохраняем старый сжатый pkglist
		if [ -f "$basedir/pkglist.$meta.bz2" ]; then
			mv -f "$basedir/pkglist.$meta.bz2" "$basedir/pkglist.$meta.bz2.old"
		fi

		bzip2 $bz2opts -c "$basedir/pkglist.$meta" > "$basedir/pkglist.$meta.bz2"

		# Сравнение с предыдущим сжатым pkglist
		if [ -f "$basedir/pkglist.$meta.bz2.old" ]; then
			if cmp -s "$basedir/pkglist.$meta.bz2.old" "$basedir/pkglist.$meta.bz2"; then
				mv -f "$basedir/pkglist.$meta.bz2.old" "$basedir/pkglist.$meta.bz2"
			fi
		fi

		rm -f "$basedir/pkglist.$meta.old" "$basedir/pkglist.$meta.bz2.old"
	fi

	printf "%s\n" " [готово]"

	printf "%s" "Обрабатываю srclists..."

	if [ -n "$meta" ]; then
		if [ -f "$basedir/srclist.$meta" ]; then
			mv -f "$basedir/srclist.$meta" "$basedir/srclist.$meta.old"
		fi
	fi

	for comp in $components; do
		if [ -z "$flat" ]; then
			srctopdir=$(cd "$topdir/.." 2>/dev/null && pwd)
		else
			srctopdir=$(cd "$topdir" 2>/dev/null && pwd)
		fi

		[ -n "$srctopdir" ] || continue

		if [ ! -d "$srctopdir/SRPMS.$comp" ]; then
			continue
		fi

		printf " %s" "$comp"

		# Обычный репозиторий: сохраняем старый srclist
		if [ -z "$meta" ] && [ -f "$basedir/srclist.$comp" ]; then
			mv -f "$basedir/srclist.$comp" "$basedir/srclist.$comp.old"
		fi

		if [ "$mapi" -ne 0 ]; then
			(
				cd "$basedir" || exit 1
				gensrclist $progress $flat $meta_opts $append_opt $cacheopts \
					--mapi "$srctopdir" "$comp" "$srcidxdir/srcidx.$comp"
			) || die "ошибка: gensrclist завершился с ошибкой (компонент: $comp)"
		else
			(
				cd "$basedir" || exit 1
				gensrclist $progress $flat $meta_opts $append_opt $cacheopts \
					"$srctopdir" "$comp" "$srcidxdir/srcidx"
			) || die "ошибка: gensrclist завершился с ошибкой (компонент: $comp)"
		fi

		if [ -z "$meta" ] && [ -f "$basedir/srclist.$comp" ]; then

			# Сравнение с предыдущим srclist
			if [ -f "$basedir/srclist.$comp.old" ]; then
				if cmp -s "$basedir/srclist.$comp.old" "$basedir/srclist.$comp"; then
					mv -f "$basedir/srclist.$comp.old" "$basedir/srclist.$comp"
				fi
			fi

			# Сохраняем старый сжатый srclist
			if [ -f "$basedir/srclist.$comp.bz2" ]; then
				mv -f "$basedir/srclist.$comp.bz2" "$basedir/srclist.$comp.bz2.old"
			fi

			bzip2 $bz2opts -c "$basedir/srclist.$comp" > "$basedir/srclist.$comp.bz2"

			# Сравнение с предыдущим сжатым srclist
			if [ -f "$basedir/srclist.$comp.bz2.old" ]; then
				if cmp -s "$basedir/srclist.$comp.bz2.old" "$basedir/srclist.$comp.bz2"; then
					mv -f "$basedir/srclist.$comp.bz2.old" "$basedir/srclist.$comp.bz2"
				fi
			fi

			rm -f "$basedir/srclist.$comp.old" "$basedir/srclist.$comp.bz2.old"
		fi

		rm -f "$srcidxdir/srcidx.$comp"
	done

	if [ -n "$meta" ] && [ -f "$basedir/srclist.$meta" ]; then

		# Сравнение с предыдущим srclist
		if [ -f "$basedir/srclist.$meta.old" ]; then
			if cmp -s "$basedir/srclist.$meta.old" "$basedir/srclist.$meta"; then
				mv -f "$basedir/srclist.$meta.old" "$basedir/srclist.$meta"
			fi
		fi

		# Сохраняем старый сжатый srclist
		if [ -f "$basedir/srclist.$meta.bz2" ]; then
			mv -f "$basedir/srclist.$meta.bz2" "$basedir/srclist.$meta.bz2.old"
		fi

		bzip2 $bz2opts -c "$basedir/srclist.$meta" > "$basedir/srclist.$meta.bz2"

		# Сравнение с предыдущим сжатым srclist
		if [ -f "$basedir/srclist.$meta.bz2.old" ]; then
			if cmp -s "$basedir/srclist.$meta.bz2.old" "$basedir/srclist.$meta.bz2"; then
				mv -f "$basedir/srclist.$meta.bz2.old" "$basedir/srclist.$meta.bz2"
			fi
		fi

		rm -f "$basedir/srclist.$meta.old" "$basedir/srclist.$meta.bz2.old"
	fi

	printf "%s\n" " [готово]"

fi

# Удаляем временный каталог индексов (если создавался)
if [ -n "$srcidxdir" ] && [ -d "$srcidxdir" ]; then
	rm -rf "$srcidxdir"
fi

# Если meta-репозиторий — далее работаем с ним как с единственным компонентом
if [ -n "$meta" ]; then
	components=$meta
fi

if [ "$listonly" -ne 0 ]; then
	# В режиме --listonly ничего больше не делаем
	# Если был указан --bz2only — удаляем несжатые списки (для всех компонентов)
	if [ "$bz2only" -eq 1 ]; then
		for comp in $components; do
			[ -f "$pkglist.$comp" ] && rm -f "$pkglist.$comp"
			[ -f "$srclist.$comp" ] && rm -f "$srclist.$comp"
		done
	fi
else
	# --------------------------
	# Release для компонентов
	# --------------------------

	printf "%s" "Обновляю release для компонентов..."
	for comp in $components; do
		printf " %s" "$comp"
		if [ -f "$release.$comp" ]; then
			mv -f "$release.$comp" "$release.$comp.old"
			sed -e "/\(Package\|Source\)Count:/d" \
				"$release.$comp.old" > "$release.$comp"
			rm -f "$release.$comp.old"
		else
			# ВНИМАНИЕ: поля Release — это формат Debian/apt, их не переводим
			echo "Archive: Unknown"      >> "$release.$comp"
			echo "Component: $comp"      >> "$release.$comp"
			echo "Version: Unknown"      >> "$release.$comp"
			echo "Origin: Unknown"       >> "$release.$comp"
			echo "Label: Unknown"        >> "$release.$comp"
			echo "Architecture: unknown" >> "$release.$comp"
			echo "NotAutomatic: false"   >> "$release.$comp"
		fi
		if [ -f "$pkglist.$comp" ]; then
			echo "PackageCount: $(countpkglist "$pkglist.$comp")" >> "$release.$comp"
		fi
		if [ -f "$srclist.$comp" ]; then
			echo "SourceCount: $(countpkglist "$srclist.$comp")" >> "$release.$comp"
		fi
	done
	printf "%s\n" " [готово]"

	# -------------
	# Глобальный Release
	# -------------

	if [ -f "$release" ]; then
		mv -f "$release" "$release.old"
		if [ "$partial" -eq 0 ]; then
			printf "%s" "Обновляю глобальный release... "
			sed -n -e "/^MD5Sum:/q" \
			       -e "s/^Date:.*\$/Date: $(date -R)/" \
			       -e "s/^Components:.*\$/Components: $components/" \
			       -e "p" "$release.old" > "$release"
			echo "MD5Sum:" >> "$release"
		else
			printf "%s" "Частично обновляю глобальный release... "
			sed -n -e "/^\$/q" \
			       -e "s/^Date:.*\$/Date: $(date -R)/" \
			       -e "p" "$release.old" > "$release.pre"
			for comp in $components; do
				sed -e "\#^ .* $pkglist_.$comp\(.bz2\)\?\$#d" \
				    -e "\#^ .* $srclist_.$comp\(.bz2\)\?\$#d" \
				    -e "\#^ .* $release_.$comp\(.bz2\)\?\$#d" \
				    -e "s/^\(Components:.*\) $comp\(.*\)\$/\1\2/" \
					"$release.pre" > "$release.tmp"
				mv -f "$release.tmp" "$release.pre"
			done
			sed -e "s/^\(Components:.*\)\$/\1 $components/" \
				"$release.pre" > "$release"
			rm -f "$release.pre"
		fi
		printf "%s\n" "[готово]"
	else
		printf "%s" "Создаю глобальный release... "
		# ВНИМАНИЕ: поля Release — это формат Debian/apt, их не переводим
		echo "Origin: Unknown"            >> "$release"
		echo "Label: Unknown"             >> "$release"
		echo "Suite: Unknown"             >> "$release"
		echo "Codename: Unknown"          >> "$release"
		echo "Date: $(date -R)"           >> "$release"
		echo "Architectures: Unknown"     >> "$release"
		echo "Components: $components"    >> "$release"
		echo "Description: Not available" >> "$release"
		echo "MD5Sum:"                    >> "$release"
		printf "%s\n" "[готово]"
	fi

	printf "%s" "Дописываю MD5Sum..."

	for comp in $components; do
		printf " %s" "$comp"
		if [ -f "$pkglist.$comp" ]; then
			phashstuff "$pkglist.$comp" "$pkglist_.$comp" >> "$release"
			if [ "$bz2only" -eq 1 ]; then
				rm -f "$pkglist.$comp"
			fi
		fi
		if [ -f "$srclist.$comp" ]; then
			phashstuff "$srclist.$comp" "$srclist_.$comp" >> "$release"
			if [ "$bz2only" -eq 1 ]; then
				rm -f "$srclist.$comp"
			fi
		fi
		if [ -f "$pkglist.$comp.bz2" ]; then
			phashstuff "$pkglist.$comp.bz2" "$pkglist_.$comp.bz2" >> "$release"
		fi
		if [ -f "$srclist.$comp.bz2" ]; then
			phashstuff "$srclist.$comp.bz2" "$srclist_.$comp.bz2" >> "$release"
		fi
		if [ -f "$release.$comp" ]; then
			phashstuff "$release.$comp" "$release_.$comp" >> "$release"
		fi
	done
	printf "%s\n" " [готово]"

	echo >> "$release"

	if [ "$signature" -ne 0 ]; then
		# eval — потому что $defaultkey может содержать пробелы (внутри кавычек)
		eval gpg --sign -armour --detach-sign --yes --quiet $defaultkey "$release"
		cat "$release.asc" >> "$release"
		rm -f "$release.asc"
	fi

	# Сравнение с предыдущим release
	if [ -f "$release.old" ]; then
		if cmp -s "$release.old" "$release"; then
			mv -f "$release.old" "$release"
		fi
		rm -f "$release.old"
	fi
fi

# ----------------
# Старый hashfile
# ----------------

if [ "$oldhashfile" -ne 0 ] && [ "$listonly" -eq 0 ]; then
	# Сохраняем старый hashfile
	hf=$basedir/hashfile
	if [ -f "$hf" ]; then
		mv -f "$hf" "$hf.old"
		if [ "$partial" -eq 0 ]; then
			printf "%s" "Обновляю legacy hashfile... "
			echo "MD5SUM:" > "$hf"
		else
			printf "%s" "Частично обновляю legacy hashfile... "
			sed -n -e "/^\$/q;p" "$hf.old" > "$hf.pre"
			for comp in $components; do
				sed -e "\#^ .* $pkglist_.$comp\(.bz2\)\?\$#d" \
				    -e "\#^ .* $srclist_.$comp\(.bz2\)\?\$#d" \
				    -e "\#^ .* $release_.$comp\(.bz2\)\?\$#d" \
					"$hf.pre" > "$hf.tmp"
				mv -f "$hf.tmp" "$hf.pre"
			done
			mv -f "$hf.pre" "$hf"
		fi
	else
		printf "%s" "Создаю legacy hashfile... "
		echo "MD5SUM:" > "$hf"
	fi
	printf "%s\n" "[готово]"

	printf "%s" "Дописываю MD5Sum..."

	for comp in $components; do
		printf " %s" "$comp"

		if [ -f "$pkglist.$comp" ]; then
			phashstuff "$pkglist.$comp" "$pkglist_.$comp" >> "$hf"
		fi
		if [ -f "$srclist.$comp" ]; then
			phashstuff "$srclist.$comp" "$srclist_.$comp" >> "$hf"
		fi
		if [ -f "$pkglist.$comp.bz2" ]; then
			phashstuff "$pkglist.$comp.bz2" "$pkglist_.$comp.bz2" >> "$hf"
		fi
		if [ -f "$srclist.$comp.bz2" ]; then
			phashstuff "$srclist.$comp.bz2" "$srclist_.$comp.bz2" >> "$hf"
		fi
		if [ -f "$release.$comp" ]; then
			phashstuff "$release.$comp" "$release_.$comp" >> "$hf"
		fi
	done
	printf "%s\n" " [готово]"

	echo >> "$hf"

	# Сравнение с предыдущим hashfile
	if [ -f "$basedir/hashfile.old" ]; then
		if cmp -s "$basedir/hashfile.old" "$basedir/hashfile"; then
			mv -f "$basedir/hashfile.old" "$basedir/hashfile"
		fi
	fi

	if [ "$signature" -ne 0 ]; then

		# Сохраняем старый hashfile.gpg
		if [ -f "$basedir/hashfile.gpg" ]; then
			mv -f "$basedir/hashfile.gpg" "$basedir/hashfile.gpg.old"
		fi

		# eval — потому что $defaultkey может содержать пробелы (внутри кавычек)
		eval gpg --sign --armour --yes --quiet $defaultkey "$basedir/hashfile"
		mv -f "$basedir/hashfile.asc" "$basedir/hashfile.gpg"

		# Сравнение с предыдущим hashfile.gpg
		if [ -f "$basedir/hashfile.gpg.old" ]; then
			if cmp -s "$basedir/hashfile.gpg.old" "$basedir/hashfile.gpg"; then
				mv -f "$basedir/hashfile.gpg.old" "$basedir/hashfile.gpg"
			fi
		fi
	fi

	rm -f "$basedir/hashfile.old" "$basedir/hashfile.gpg.old"
fi

printf "%s\n" "Готово."

# vim:ts=4:sw=4 (поведение сохранено)
